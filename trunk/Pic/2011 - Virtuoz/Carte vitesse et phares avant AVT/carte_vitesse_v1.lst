CCS PCH C Compiler, Version 4.057, 32216               27-avr.-11 17:22

               Filename: carte_vitesse_v1.lst

               ROM used: 2752 bytes (8%)
                         Largest free fragment is 30012
               RAM used: 40 (3%) at main() level
                         84 (5%) worst case
               Stack:    3 worst case (2 in main + 1 for interrupts)

*
0000:  GOTO   06A4
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVFF  FE0,07
0012:  MOVLB  0
0014:  MOVFF  FE9,0D
0018:  MOVFF  FEA,08
001C:  MOVFF  FE1,09
0020:  MOVFF  FE2,0A
0024:  MOVFF  FD9,0B
0028:  MOVFF  FDA,0C
002C:  MOVFF  FF3,14
0030:  MOVFF  FF4,15
0034:  MOVFF  FFA,16
0038:  MOVFF  00,0F
003C:  MOVFF  01,10
0040:  MOVFF  02,11
0044:  MOVFF  03,12
0048:  MOVFF  04,13
004C:  BTFSS  F9D.1
004E:  GOTO   0058
0052:  BTFSC  F9E.1
0054:  GOTO   009E
0058:  MOVFF  0F,00
005C:  MOVFF  10,01
0060:  MOVFF  11,02
0064:  MOVFF  12,03
0068:  MOVFF  13,04
006C:  BSF    0E.7
006E:  MOVFF  0D,FE9
0072:  MOVFF  08,FEA
0076:  MOVFF  09,FE1
007A:  MOVFF  0A,FE2
007E:  MOVFF  0B,FD9
0082:  MOVFF  0C,FDA
0086:  MOVFF  14,FF3
008A:  MOVFF  15,FF4
008E:  MOVFF  16,FFA
0092:  MOVF   05,W
0094:  MOVFF  07,FE0
0098:  MOVFF  06,FD8
009C:  RETFIE 0
.................... // 
.................... //      Carte Vitesse et Phares avant 
.................... //      Version 1.0 - HDT - 08/03/2011 
.................... //      Version 1.1 - HDT - 15/03/2011 
.................... //      Version 1.2 - HDT - 20/04/2011 
.................... //      Version 1.3 - HDT - 24/04/2011 
.................... // 
....................  
.................... // Vitesse : regarder toutes les secondes la valeur du timer puis remettre à zéro 
.................... // OU 
.................... // Si trop lent : regarder le temps entre deux fronts montants (critère : moins de X fronts montants/seconde 
....................  
.................... // TODO : refaire la prog, timers en external pour la mesure de vitesse. 
....................  
.................... #include <18F2580.h> 
.................... //////// Standard Header file for the PIC18F2580 device //////////////// 
.................... #device PIC18F2580 
.................... #list 
....................  
.................... #include <can-18xxx8.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.c                             //// 
.................... //// CAN Library routines for Microchip's PIC18Cxx8 and 18Fxx8 line  //// 
.................... ////                                                                 //// 
.................... //// This library provides the following functions:                  //// 
.................... ////  (for more information on these functions see the comment       //// 
.................... ////   header above each function)                                   //// 
.................... ////                                                                 //// 
.................... ////    can_init - Configures the PIC18xxx8 CAN peripheral           //// 
.................... ////                                                                 //// 
.................... ////    can_set_baud - Sets the baud rate control registers          //// 
.................... ////                                                                 //// 
.................... ////    can_set_mode - Sets the CAN module into a specific mode      //// 
.................... ////                                                                 //// 
.................... ////    can_set_id - Sets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_get_id - Gets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_putd - Sends a message/request with specified ID         //// 
.................... ////                                                                 //// 
.................... ////    can_getd - Returns specifid message/request and ID           //// 
.................... ////                                                                 //// 
.................... ////    can_kbhit - Returns true if there is data in one of the      //// 
.................... ////                receive buffers                                  //// 
.................... ////                                                                 //// 
.................... ////    can_tbe - Returns true if the transmit buffer is ready to    //// 
.................... ////              send more data                                     //// 
.................... ////                                                                 //// 
.................... ////    can_abort - Aborts all pending transmissions                 //// 
.................... ////                                                                 //// 
.................... //// PIN_B3 is CANRX, and PIN_B2 is CANTX.  You will need a CAN      //// 
.................... //// transeiver to connect these pins to CANH and CANL bus lines.    //// 
.................... ////                                                                 //// 
.................... //// CCS provides an example, ex_can.c, which shows how to use this  //// 
.................... //// library.                                                        //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History                                                 //// 
.................... ////                                                                 //// 
.................... ////  Jul 27 04 - can_init() uses CAN_USE_EXTENDED_ID instead of     //// 
.................... ////              setting all RX filters to extended.                //// 
.................... ////                                                                 //// 
.................... ////  Feb 24 04 - can_get_id() fixed for EID<18:20>.                 //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <can-18xxx8.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.h                             //// 
.................... ////                                                                 //// 
.................... //// Prototypes, definitions, defines and macros used for and with   //// 
.................... //// the CCS CAN library for PIC18Fxx8 and PIC18Cxx8.                //// 
.................... ////                                                                 //// 
.................... //// (see can-18xxx8.c)                                              //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __CCS_CAN18xxx8_LIB_DEFINES__ 
.................... #define __CCS_CAN18xxx8_LIB_DEFINES__ 
....................  
.................... #ifndef CAN_DO_DEBUG 
....................  #define CAN_DO_DEBUG FALSE 
.................... #endif 
....................  
.................... #IFNDEF CAN_USE_EXTENDED_ID 
....................   #define CAN_USE_EXTENDED_ID         TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_SYNCH_JUMP_WIDTH 
....................   #define CAN_BRG_SYNCH_JUMP_WIDTH  0  //synchronized jump width (def: 1 x Tq) 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_PRESCALAR 
....................   #define CAN_BRG_PRESCALAR  4  //baud rate generator prescalar (def: 4) ( Tq = (2 x (PRE + 1))/Fosc ) 
.................... #ENDIF 
....................  
.................... #ifndef CAN_BRG_SEG_2_PHASE_TS 
....................  #define CAN_BRG_SEG_2_PHASE_TS   TRUE //phase segment 2 time select bit (def: freely programmable) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_SAM 
....................  #define CAN_BRG_SAM 0 //sample of the can bus line (def: bus line is sampled 1 times prior to sample point) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_1 
....................  #define CAN_BRG_PHASE_SEGMENT_1  5 //phase segment 1 (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PROPAGATION_TIME 
....................  #define CAN_BRG_PROPAGATION_TIME 2 //propagation time select (def: 3 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_WAKE_FILTER 
....................  #define CAN_BRG_WAKE_FILTER FALSE   //selects can bus line filter for wake up bit 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_2 
....................  #define CAN_BRG_PHASE_SEGMENT_2 5 //phase segment 2 time select (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_USE_RX_DOUBLE_BUFFER 
....................  #define CAN_USE_RX_DOUBLE_BUFFER TRUE   //if buffer 0 overflows, do NOT use buffer 1 to put buffer 0 data 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_DRIVE_HIGH 
....................  #define CAN_ENABLE_DRIVE_HIGH 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CAN_CAPTURE 
....................  #define CAN_ENABLE_CAN_CAPTURE 0 
.................... #endif 
....................  
.................... enum CAN_OP_MODE {CAN_OP_CONFIG=4, CAN_OP_LISTEN=3, CAN_OP_LOOPBACK=2, CAN_OP_DISABLE=1, CAN_OP_NORMAL=0}; 
.................... enum CAN_WIN_ADDRESS {CAN_WIN_RX0=0, CAN_WIN_RX1=5, CAN_WIN_TX0=4, CAN_WIN_TX1=3, CAN_WIN_TX2=2}; 
....................  
.................... //can control 
.................... struct { 
.................... 	int1 void0; //0 
.................... 	CAN_WIN_ADDRESS win:3;	//1:3 //window address bits 
.................... 	int1 abat;	//4 //abort all pending transmissions 
.................... 	CAN_OP_MODE reqop:3;	//5:7	//request can operation mode bits 
.................... } CANCON; 
.................... #byte CANCON = 0xF6F 
....................  
....................  
.................... enum CAN_INT_CODE {CAN_INT_WAKEUP=7, CAN_INT_RX0=6, CAN_INT_RX1=5, CAN_INT_TX0=4, CAN_INT_TX1=3, CAN_INT_TX2=2, CAN_INT_ERROR=1, CAN_INT_NO=0}; 
....................  
.................... //can status register READ-ONLY 
.................... struct { 
.................... 	int1 void0;	//0 
.................... 	CAN_INT_CODE icode:3;	//1:3	//interrupt code 
.................... 	int1 void4;	//4 
.................... 	CAN_OP_MODE opmode:3;	//5:7	//operation mode status 
.................... } CANSTAT; 
.................... #byte CANSTAT = 0xF6E 
....................  
.................... //communication status register READ-ONLY 
.................... struct { 
.................... 	int1 ewarn;		//0 //error warning 
.................... 	int1 rxwarn;		//1 //receiver warning 
.................... 	int1 txwarn;		//2 //transmitter warning 
.................... 	int1 rxbp;	//3 //receiver bus passive 
.................... 	int1 txbp;	//4 //transmitter bus passive bit 
.................... 	int1 txbo;	//5	//transmitter bus off 
.................... 	int1 rx1ovfl;	//6	//receive buffer 1 overflow 
.................... 	int1 rx0ovfl;	//7	//receive buffer 0 overflow 
.................... } COMSTAT; 
.................... #byte COMSTAT=0xF74 
....................  
.................... //baud rate control register 1 
.................... struct { 
.................... 	int brp:6;	//0:5	//baud rate prescalar 
.................... 	int sjw:2;	//6:7	//synchronized jump width 
.................... } BRGCON1; 
.................... #byte BRGCON1=0xF70 
....................  
.................... //baud rate control register 2 
.................... struct { 
.................... 	int prseg:3; //0:2 //propagation time select 
.................... 	int seg1ph:3; //3:5 //phase segment 1 
.................... 	int1 sam; //6 //sample of the can bus line 
.................... 	int1 seg2phts; //7 //phase segment 2 time select 
.................... } BRGCON2; 
.................... #byte BRGCON2=0xF71 
....................  
.................... //baud rate control register 3 
.................... struct { 
.................... 	int seg2ph:3;	//0:2	//phase segment 2 time select 
.................... 	int void543:3;	//3:5 
.................... 	int1 wakfil;	//6 //selects can bus line filter for wake-up 
.................... 	int1 void7;	//7 
.................... } BRGCON3; 
.................... #byte BRGCON3=0xF72 
....................  
.................... //can i/o control register 
.................... struct { 
.................... 	int void3210:4;	//0:3 
.................... 	int1 cancap;	//4 //can message receive caputre 
.................... 	int1 endrhi;	//5 //enable drive high 
.................... 	int void76:2;	//6:7 
.................... } CIOCON; 
.................... #byte CIOCON=0xF73 
....................  
.................... //transmit buffer n control register 
.................... struct txbNcon_struct { 
.................... 	int  txpri:2;	//0:1	//transmit priority bits 
.................... 	int1 void2; //2 
.................... 	int1 txreq;	//3	//transmit request status (clear to request message abort) 
.................... 	int1 txerr;	//4	//transmission error detected 
.................... 	int1 txlarb;	//5	//transmission lost arbitration status 
.................... 	int1 txabt;	//6	//transmission aborted status 
.................... 	int1 void7; 
.................... }; 
.................... struct txbNcon_struct TXB0CON; 
.................... struct txbNcon_struct TXB1CON; 
.................... struct txbNcon_struct TXB2CON; 
.................... struct txbNcon_struct TXBaCON; 
.................... #byte	TXB0CON=0xF40 
.................... #byte	TXB1CON=0xF30 
.................... #byte	TXB2CON=0xF20 
.................... #byte TXBaCON=0xF60 //txbXcon when in the access bank 
....................  
....................  
.................... //transmit buffer n standard identifier 
.................... #byte TXB0SIDH=0xF41 
.................... #byte TXB0SIDL=0xF42 
.................... #byte TXB1SIDH=0xF31 
.................... #byte TXB1SIDL=0xF32 
.................... #byte TXB2SIDH=0xF21 
.................... #byte TXB2SIDL=0xF22 
....................  
.................... //transmit buffer n extended identifier 
.................... #byte TXB0EIDH=0xF43 
.................... #byte TXB0EIDL=0xF44 
.................... #byte TXB1EIDH=0xF33 
.................... #byte TXB1EIDL=0xF34 
.................... #byte TXB2EIDH=0xF23 
.................... #byte TXB2EIDL=0xF24 
....................  
.................... #define RX0MASK      0xF1B    //rxm0eidl 
.................... #define RX1MASK      0xF1F    //rxm1eidl 
.................... #define RX0FILTER0   0xF03    //rxf0eidl 
.................... #define RX0FILTER1   0xF07    //rxf1eidl 
.................... #define RX1FILTER2   0xF0B    //rxf2eidl 
.................... #define RX1FILTER3   0xF0F    //rxf3eidl 
.................... #define RX1FILTER4   0xF13    //rxf4eidl 
.................... #define RX1FILTER5   0xF17    //rxf5eidl 
.................... #define RXB0ID       0xF64    //rxb0eidl 
.................... #define RXB1ID       0xF54    //rxb1eidl 
.................... #define TXB0ID       0xF44    //txb0eidl 
.................... #define TXB1ID       0xF34    //txb1eidl 
.................... #define TXB2ID       0xF24    //tsb2eidl 
.................... #define TXRXBaID     0xF64 
....................  
.................... //transmit buffer n data byte m 
.................... #byte TXB0D0=0xF46 
.................... #byte TXB0D7=0xF4D 
.................... #byte TXB1D0=0xF36 
.................... #byte TXB1D7=0xF3D 
.................... #byte TXB2D0=0xF26 
.................... #byte TXB2D7=0xF2D 
....................  
.................... //transmit buffer n data length 
.................... struct txbNdlc_struct { 
.................... 	int dlc:4;	//0:3 
.................... 	int void54:2; //4:5 
.................... 	int1 rtr; //6 //transmission frame remote tranmission 
.................... 	int1 void7; //7 
.................... }; 
.................... struct txbNdlc_struct TXB0DLC; 
.................... struct txbNdlc_struct TXB1DLC; 
.................... struct txbNdlc_struct TXB2DLC; 
.................... struct txbNdlc_struct TXBaDLC; 
.................... #byte TXB0DLC=0xF45 
.................... #byte TXB1DLC=0xF35 
.................... #byte TXB2DLC=0xF25 
.................... #byte TXBaDLC=0xF65  //txbXdlc when in the access bank 
....................  
....................  
.................... //transmit error count register 
.................... #byte TXERRCNT=0xF76 
....................  
....................  
.................... enum CAN_RX_MODE {CAN_RX_ALL=3, CAN_RX_EXT=2, CAN_RX_STD=1, CAN_RX_VALID=0}; 
....................  
.................... //receive buffer 0 control register 
.................... struct { 
.................... 	int1 filthit0;	//0 //filter hit 
.................... 	int1 jtoff;	//1 //jump table offset 
.................... 	int1 rxb0dben;	//2 //receive buffer 0 double buffer enable 
.................... 	int1 rxrtrro;	//3 //receive remote transfer request 
.................... 	int1 void4;	//4 
.................... 	CAN_RX_MODE rxm:2;	//5:6 //receiver buffer mode 
.................... 	int1 rxful;	//7 //receive full status 
.................... } RXB0CON; 
.................... #byte RXB0CON=0xF60 
....................  
.................... //receive buffer 1 control register 
.................... struct { 
.................... 	int filthit:3;	//0:2 
.................... 	int1 rxrtrro;	//3 //receive remote transfer request 
.................... 	int1 void4;	//4 
.................... 	CAN_RX_MODE rxm:2;	//5:6 //receive buffer mode 
.................... 	int1 rxful;	//7	//receive full 
.................... } RXB1CON; 
.................... #byte	RXB1CON=0xF50 
....................  
....................  
.................... //receive buffer n standard identifier 
.................... #byte	RXB0SIDH=0xF61 
.................... #byte	RXB0SIDL=0xF62 
.................... #byte	RXB1SIDH=0xF51 
.................... #byte	RXB1SIDL=0xF52 
....................  
.................... //receive buffer n extended identifier 
.................... #byte	RXB0EIDH=0xF63 
.................... #byte	RXB0EIDL=0xF64 
.................... #byte	RXB1EIDH=0xF53 
.................... #byte	RXB1EIDL=0xF54 
....................  
.................... #byte TXRXBaEIDL=0xF64 
....................  
.................... struct { 
....................    int void012:3; //0:3 
....................    int1 ext;   //extendid id 
....................    int1 srr;   //substitute remove request bit 
....................    int void567:3; //5:7 
.................... } TXRXBaSIDL; 
.................... #byte TXRXBaSIDL=0xF62 
....................  
.................... //receive buffer n data length code register 
.................... struct rxbNdlc_struct { 
.................... 	int dlc:4;	//0:3 //data length code 
.................... 	int1 rb0; //4 //reserved 
.................... 	int1 rb1;	//5 //reserved 
.................... 	int1 rtr;	//6 //receiver remote transmission request bit 
.................... 	int1 void7;	//7 
.................... }; 
.................... struct rxbNdlc_struct RXB0DLC; 
.................... struct rxbNdlc_struct RXB1DLC; 
.................... struct rxbNdlc_struct RXBaDLC; 
.................... #byte	RXB0DLC=0xF65 
.................... #byte	RXB1DLC=0xF55 
.................... #byte	RXBaDLC=0xF65 
....................  
.................... //receive buffer n data field byte m register 
.................... #byte RXB0D0=0xF66 
.................... #byte RXB0D7=0xF6D 
.................... #byte TXRXBaD0=0xF66 
.................... #byte TXRXBaD7=0xF6D 
....................  
.................... //receive error count 
.................... #byte RXERRCNT=0xF75 
....................  
.................... //receive acceptance filter n standard indifier 
.................... #byte RXF0SIDH=0xF00 
.................... #byte RXF0SIDL=0xF01 
.................... #byte RXF1SIDH=0xF04 
.................... #byte RXF1SIDL=0xF05 
.................... #byte RXF2SIDH=0xF08 
.................... #byte RXF2SIDL=0xF09 
.................... #byte RXF3SIDH=0xF0C 
.................... #byte RXF3SIDL=0xF0D 
.................... #byte RXF4SIDH=0xF10 
.................... #byte RXF4SIDL=0xF11 
.................... #byte RXF5SIDH=0xF14 
.................... #byte RXF5SIDL=0xF15 
....................  
.................... //receive acceptance filter n extended indifier 
.................... #byte RXF0EIDH=0xF02 
.................... #byte RXF0EIDL=0xF03 
.................... #byte RXF1EIDH=0xF06 
.................... #byte RXF1EIDL=0xF07 
.................... #byte RXF2EIDH=0xF0A 
.................... #byte RXF2EIDL=0xF0B 
.................... #byte RXF3EIDH=0xF0E 
.................... #byte RXF3EIDL=0xF0F 
.................... #byte RXF4EIDH=0xF12 
.................... #byte RXF4EIDL=0xF13 
.................... #byte RXF5EIDH=0xF16 
.................... #byte RXF5EIDL=0xF17 
....................  
.................... //receive acceptance mask n standard identifer mask 
.................... #byte RXM0SIDH=0xF18 
.................... #byte RXM0SIDL=0xF19 
.................... #byte RXM1SIDH=0xF1C 
.................... #byte RXM1SIDL=0xF1D 
....................  
.................... //receive acceptance mask n extended identifer mask 
.................... #byte RXM0EIDH=0xF1A 
.................... #byte RXM0EIDL=0xF1B 
.................... #byte RXM1EIDH=0xF1E 
.................... #byte RXM1EIDL=0xF1F 
....................  
.................... //value to put in mask field to accept all incoming id's 
.................... #define CAN_MASK_ACCEPT_ALL   0 
....................  
.................... //can interrupt flags 
.................... #bit CAN_INT_IRXIF = 0xFA4.7 
.................... #bit CAN_INT_WAKIF = 0xFA4.6 
.................... #bit CAN_INT_ERRIF = 0xFA4.5 
.................... #bit CAN_INT_TXB2IF = 0xFA4.4 
.................... #bit CAN_INT_TXB1IF = 0xFA4.3 
.................... #bit CAN_INT_TXB0IF = 0xFA4.2 
.................... #bit CAN_INT_RXB1IF = 0xFA4.1 
.................... #bit CAN_INT_RXB0IF = 0xFA4.0 
....................  
.................... //PROTOTYPES 
....................  
.................... struct rx_stat { 
....................    int1 err_ovfl; 
....................    int filthit:3; 
....................    int1 buffer; 
....................    int1 rtr; 
....................    int1 ext; 
....................    int1 inv; 
.................... }; 
....................  
.................... void  can_init(void); 
.................... void  can_set_baud(void); 
.................... void  can_set_mode(CAN_OP_MODE mode); 
.................... void  can_set_id(int* addr, int32 id, int1 ext); 
.................... int32 can_get_id(int * addr, int1 ext); 
.................... int   can_putd(int32 id, int * data, int len, int priority, int1 ext, int1 rtr); 
.................... int1  can_getd(int32 & id, int * data, int & len, struct rx_stat & stat); 
....................  
.................... #endif 
....................  
....................  
.................... #if CAN_DO_DEBUG 
....................  #define can_debug printf 
.................... #else 
....................  #define can_debug 
.................... #endif 
....................  
....................  
.................... //macros 
.................... #define can_kbhit()                 (RXB0CON.rxful || RXB1CON.rxful) 
.................... #define can_tbe()                   (!TXB0CON.txreq || !TXB1CON.txreq || !TXB2CON.txreq) 
.................... #define can_abort()                 (CANCON.abat=1) 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_init() 
.................... // 
.................... // Initializes PIC18xxx8 CAN peripheral.  Sets the RX filter and masks so the 
.................... // CAN peripheral will receive all incoming IDs.  Configures both RX buffers 
.................... // to only accept valid valid messages (as opposed to all messages, or all 
.................... // extended message, or all standard messages).  Also sets the tri-state 
.................... // setting of B2 to output, and B3 to input (apparently the CAN peripheral 
.................... // doesn't keep track of this) 
.................... // 
.................... // The constants (CAN_USE_RX_DOUBLE_BUFFER, CAN_ENABLE_DRIVE_HIGH, 
.................... // CAN_ENABLE_CAN_CAPTURE) are given a default define in the can-18xxx8.h file. 
.................... // These default values can be overwritten in the main code, but most 
.................... // applications will be fine with these defaults. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... void can_init(void) { 
....................    can_set_mode(CAN_OP_CONFIG);   //must be in config mode before params can be set 
*
0254:  MOVLW  04
0256:  MOVWF  28
0258:  RCALL  00D4
....................    can_set_baud(); 
025A:  RCALL  00F6
....................  
....................    RXB0CON=0; 
025C:  CLRF   F60
....................    RXB0CON.rxm=CAN_RX_VALID; 
025E:  MOVLW  9F
0260:  ANDWF  F60,W
0262:  MOVWF  F60
....................    RXB0CON.rxb0dben=CAN_USE_RX_DOUBLE_BUFFER; 
0264:  BSF    F60.2
....................    RXB1CON=RXB0CON; 
0266:  MOVFF  F60,F50
....................  
....................    CIOCON.endrhi=CAN_ENABLE_DRIVE_HIGH; 
026A:  BCF    F73.5
....................    CIOCON.cancap=CAN_ENABLE_CAN_CAPTURE; 
026C:  BCF    F73.4
....................  
....................    can_set_id(RX0MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 0 
026E:  MOVLW  0F
0270:  MOVWF  45
0272:  MOVLW  1B
0274:  MOVWF  44
0276:  CLRF   49
0278:  CLRF   48
027A:  CLRF   47
027C:  CLRF   46
027E:  MOVLW  01
0280:  MOVWF  4A
0282:  RCALL  0124
....................    can_set_id(RX0FILTER0, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 0 
0284:  MOVLW  0F
0286:  MOVWF  45
0288:  MOVLW  03
028A:  MOVWF  44
028C:  CLRF   49
028E:  CLRF   48
0290:  CLRF   47
0292:  CLRF   46
0294:  MOVLW  01
0296:  MOVWF  4A
0298:  RCALL  0124
....................    can_set_id(RX0FILTER1, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 0 
029A:  MOVLW  0F
029C:  MOVWF  45
029E:  MOVLW  07
02A0:  MOVWF  44
02A2:  CLRF   49
02A4:  CLRF   48
02A6:  CLRF   47
02A8:  CLRF   46
02AA:  MOVLW  01
02AC:  MOVWF  4A
02AE:  RCALL  0124
....................  
....................    can_set_id(RX1MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 1 
02B0:  MOVLW  0F
02B2:  MOVWF  45
02B4:  MOVLW  1F
02B6:  MOVWF  44
02B8:  CLRF   49
02BA:  CLRF   48
02BC:  CLRF   47
02BE:  CLRF   46
02C0:  MOVLW  01
02C2:  MOVWF  4A
02C4:  RCALL  0124
....................    can_set_id(RX1FILTER2, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 1 
02C6:  MOVLW  0F
02C8:  MOVWF  45
02CA:  MOVLW  0B
02CC:  MOVWF  44
02CE:  CLRF   49
02D0:  CLRF   48
02D2:  CLRF   47
02D4:  CLRF   46
02D6:  MOVLW  01
02D8:  MOVWF  4A
02DA:  RCALL  0124
....................    can_set_id(RX1FILTER3, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 1 
02DC:  MOVLW  0F
02DE:  MOVWF  45
02E0:  MOVWF  44
02E2:  CLRF   49
02E4:  CLRF   48
02E6:  CLRF   47
02E8:  CLRF   46
02EA:  MOVLW  01
02EC:  MOVWF  4A
02EE:  RCALL  0124
....................    can_set_id(RX1FILTER4, 0, CAN_USE_EXTENDED_ID);  //set filter 2 of mask 1 
02F0:  MOVLW  0F
02F2:  MOVWF  45
02F4:  MOVLW  13
02F6:  MOVWF  44
02F8:  CLRF   49
02FA:  CLRF   48
02FC:  CLRF   47
02FE:  CLRF   46
0300:  MOVLW  01
0302:  MOVWF  4A
0304:  RCALL  0124
....................    can_set_id(RX1FILTER5, 0, CAN_USE_EXTENDED_ID);  //set filter 3 of mask 1 
0306:  MOVLW  0F
0308:  MOVWF  45
030A:  MOVLW  17
030C:  MOVWF  44
030E:  CLRF   49
0310:  CLRF   48
0312:  CLRF   47
0314:  CLRF   46
0316:  MOVLW  01
0318:  MOVWF  4A
031A:  RCALL  0124
....................  
....................    set_tris_b((*0xF93 & 0xFB ) | 0x08);   //b3 is out, b2 is in 
031C:  MOVF   F93,W
031E:  ANDLW  FB
0320:  IORLW  08
0322:  MOVWF  F93
....................  
....................    can_set_mode(CAN_OP_NORMAL); 
0324:  CLRF   28
0326:  RCALL  00D4
.................... } 
0328:  GOTO   070E (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_baud() 
.................... // 
.................... // Configures the baud rate control registers.  All the defines here 
.................... // are defaulted in the can-18xxx8.h file.  These defaults can, and 
.................... // probably should, be overwritten in the main code. 
.................... // 
.................... // Current defaults are set to work with Microchip's MCP250xxx CAN 
.................... // Developers Kit if this PIC is running at 20Mhz. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_baud(void) { 
....................    BRGCON1.brp=CAN_BRG_PRESCALAR; 
*
00F6:  MOVLW  C0
00F8:  ANDWF  F70,W
00FA:  IORLW  04
00FC:  MOVWF  F70
....................    BRGCON1.sjw=CAN_BRG_SYNCH_JUMP_WIDTH; 
00FE:  MOVLW  3F
0100:  ANDWF  F70,W
0102:  MOVWF  F70
....................  
....................    BRGCON2.prseg=CAN_BRG_PROPAGATION_TIME; 
0104:  MOVLW  F8
0106:  ANDWF  F71,W
0108:  IORLW  02
010A:  MOVWF  F71
....................    BRGCON2.seg1ph=CAN_BRG_PHASE_SEGMENT_1; 
010C:  MOVLW  C7
010E:  ANDWF  F71,W
0110:  IORLW  28
0112:  MOVWF  F71
....................    BRGCON2.sam=CAN_BRG_SAM; 
0114:  BCF    F71.6
....................    BRGCON2.seg2phts=CAN_BRG_SEG_2_PHASE_TS; 
0116:  BSF    F71.7
....................  
....................    BRGCON3.seg2ph=CAN_BRG_PHASE_SEGMENT_2; 
0118:  MOVLW  F8
011A:  ANDWF  F72,W
011C:  IORLW  05
011E:  MOVWF  F72
....................    BRGCON3.wakfil=CAN_BRG_WAKE_FILTER; 
0120:  BCF    F72.6
.................... } 
0122:  RETLW  00
....................  
.................... void can_set_mode(CAN_OP_MODE mode) { 
....................    CANCON.reqop=mode; 
*
00D4:  SWAPF  28,W
00D6:  ANDLW  70
00D8:  MOVWF  00
00DA:  BCF    FD8.0
00DC:  RLCF   00,F
00DE:  MOVLW  1F
00E0:  ANDWF  F6F,W
00E2:  IORWF  00,W
00E4:  MOVWF  F6F
....................    while( (CANSTAT.opmode) != mode ); 
00E6:  MOVFF  F6E,00
00EA:  SWAPF  00,F
00EC:  RRCF   00,W
00EE:  ANDLW  07
00F0:  SUBWF  28,W
00F2:  BNZ   00E6
.................... } 
00F4:  RETLW  00
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_id() 
.................... // 
.................... // Configures the xxxxEIDL, xxxxEIDH, xxxxSIDL and xxxxSIDH registers to 
.................... // configure the defined buffer to use the specified ID 
.................... // 
.................... //   Paramaters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     id - ID to set buffer to 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_id(int* addr, int32 id, int1 ext) { 
....................    int *ptr; 
....................  
....................    ptr=addr; 
*
0124:  MOVFF  45,4C
0128:  MOVFF  44,4B
....................  
....................    if (ext) {  //extended 
012C:  MOVF   4A,F
012E:  BZ    01D4
....................       //eidl 
....................       *ptr=make8(id,0); //0:7 
0130:  MOVFF  4B,FE9
0134:  MOVFF  4C,FEA
0138:  MOVFF  46,FEF
....................  
....................       //eidh 
....................       ptr--; 
013C:  MOVF   4B,W
013E:  BTFSC  FD8.2
0140:  DECF   4C,F
0142:  DECF   4B,F
....................       *ptr=make8(id,1); //8:15 
0144:  MOVFF  4B,FE9
0148:  MOVFF  4C,FEA
014C:  MOVFF  47,FEF
....................  
....................       //sidl 
....................       ptr--; 
0150:  MOVF   4B,W
0152:  BTFSC  FD8.2
0154:  DECF   4C,F
0156:  DECF   4B,F
....................       *ptr=make8(id,2) & 0x03;   //16:17 
0158:  MOVFF  4B,FE9
015C:  MOVFF  4C,FEA
0160:  MOVF   48,W
0162:  ANDLW  03
0164:  MOVWF  FEF
....................       *ptr|=(make8(id,2) << 3) & 0xE0; //18:20 
0166:  MOVFF  4B,FE9
016A:  MOVFF  4C,FEA
016E:  MOVFF  48,00
0172:  RLCF   00,F
0174:  RLCF   00,F
0176:  RLCF   00,F
0178:  MOVLW  F8
017A:  ANDWF  00,F
017C:  MOVF   00,W
017E:  ANDLW  E0
0180:  IORWF  FEF,W
0182:  MOVWF  FEF
....................       *ptr|=0x08; 
0184:  MOVFF  4B,FE9
0188:  MOVFF  4C,FEA
018C:  MOVF   FEF,W
018E:  IORLW  08
0190:  MOVWF  FEF
....................  
....................  
....................       //sidh 
....................       ptr--; 
0192:  MOVF   4B,W
0194:  BTFSC  FD8.2
0196:  DECF   4C,F
0198:  DECF   4B,F
....................       *ptr=((make8(id,2) >> 5) & 0x07 ); //21:23 
019A:  MOVFF  4B,FE9
019E:  MOVFF  4C,FEA
01A2:  MOVFF  48,00
01A6:  SWAPF  00,F
01A8:  RRCF   00,F
01AA:  MOVLW  07
01AC:  ANDWF  00,F
01AE:  MOVF   00,W
01B0:  ANDLW  07
01B2:  MOVWF  FEF
....................       *ptr|=((make8(id,3) << 3) & 0xF8);//24:28 
01B4:  MOVFF  4B,FE9
01B8:  MOVFF  4C,FEA
01BC:  MOVFF  49,00
01C0:  RLCF   00,F
01C2:  RLCF   00,F
01C4:  RLCF   00,F
01C6:  MOVLW  F8
01C8:  ANDWF  00,F
01CA:  MOVF   00,W
01CC:  ANDLW  F8
01CE:  IORWF  FEF,W
01D0:  MOVWF  FEF
....................    } 
....................    else {   //standard 
01D2:  BRA    0252
....................       //eidl 
....................       *ptr=0; 
01D4:  MOVFF  4B,FE9
01D8:  MOVFF  4C,FEA
01DC:  CLRF   FEF
....................  
....................       //eidh 
....................       ptr--; 
01DE:  MOVF   4B,W
01E0:  BTFSC  FD8.2
01E2:  DECF   4C,F
01E4:  DECF   4B,F
....................       *ptr=0; 
01E6:  MOVFF  4B,FE9
01EA:  MOVFF  4C,FEA
01EE:  CLRF   FEF
....................  
....................       //sidl 
....................       ptr--; 
01F0:  MOVF   4B,W
01F2:  BTFSC  FD8.2
01F4:  DECF   4C,F
01F6:  DECF   4B,F
....................       *ptr=(make8(id,0) << 5) & 0xE0; 
01F8:  MOVFF  4B,FE9
01FC:  MOVFF  4C,FEA
0200:  MOVFF  46,00
0204:  SWAPF  00,F
0206:  RLCF   00,F
0208:  MOVLW  E0
020A:  ANDWF  00,F
020C:  MOVF   00,W
020E:  ANDLW  E0
0210:  MOVWF  FEF
....................  
....................       //sidh 
....................       ptr--; 
0212:  MOVF   4B,W
0214:  BTFSC  FD8.2
0216:  DECF   4C,F
0218:  DECF   4B,F
....................       *ptr=(make8(id,0) >> 3) & 0x1F; 
021A:  MOVFF  4B,FE9
021E:  MOVFF  4C,FEA
0222:  MOVFF  46,00
0226:  RRCF   00,F
0228:  RRCF   00,F
022A:  RRCF   00,F
022C:  MOVLW  1F
022E:  ANDWF  00,F
0230:  MOVF   00,W
0232:  ANDLW  1F
0234:  MOVWF  FEF
....................       *ptr|=(make8(id,1) << 5) & 0xE0; 
0236:  MOVFF  4B,FE9
023A:  MOVFF  4C,FEA
023E:  MOVFF  47,00
0242:  SWAPF  00,F
0244:  RLCF   00,F
0246:  MOVLW  E0
0248:  ANDWF  00,F
024A:  MOVF   00,W
024C:  ANDLW  E0
024E:  IORWF  FEF,W
0250:  MOVWF  FEF
....................    } 
.................... } 
0252:  RETLW  00
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_get_id() 
.................... // 
.................... // Returns the ID of the specified buffer.  (The opposite of can_set_id()) 
.................... // This is used after receiving a message, to see which ID sent the message. 
.................... // 
.................... //   Paramaters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //   Returns: 
.................... //     The ID of the buffer 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int32 can_get_id(int * addr, int1 ext) { 
....................    int32 ret; 
....................    int * ptr; 
....................  
....................    ret=0; 
*
0406:  CLRF   48
0408:  CLRF   47
040A:  CLRF   46
040C:  CLRF   45
....................    ptr=addr; 
040E:  MOVFF  43,4A
0412:  MOVFF  42,49
....................  
....................    if (ext) { 
0416:  MOVF   44,F
0418:  BTFSC  FD8.2
041A:  BRA    0532
....................       ret=*ptr;  //eidl 
041C:  MOVFF  4A,03
0420:  MOVFF  49,FE9
0424:  MOVFF  4A,FEA
0428:  MOVFF  FEF,00
042C:  CLRF   01
042E:  CLRF   02
0430:  CLRF   03
0432:  MOVFF  03,48
0436:  MOVFF  02,47
043A:  MOVFF  01,46
043E:  MOVFF  00,45
....................  
....................       ptr--;     //eidh 
0442:  MOVF   49,W
0444:  BTFSC  FD8.2
0446:  DECF   4A,F
0448:  DECF   49,F
....................       ret|=((int32)*ptr << 8); 
044A:  MOVFF  49,FE9
044E:  MOVFF  4A,FEA
0452:  MOVF   FEF,W
0454:  CLRF   4D
0456:  CLRF   4C
0458:  MOVWF  4B
045A:  CLRF   00
045C:  MOVF   00,W
045E:  IORWF  45,F
0460:  MOVF   4B,W
0462:  IORWF  46,F
0464:  MOVF   4C,W
0466:  IORWF  47,F
0468:  MOVF   4D,W
046A:  IORWF  48,F
....................  
....................       ptr--;     //sidl 
046C:  MOVF   49,W
046E:  BTFSC  FD8.2
0470:  DECF   4A,F
0472:  DECF   49,F
....................       ret|=((int32)*ptr & 0x03) << 16; 
0474:  MOVFF  49,FE9
0478:  MOVFF  4A,FEA
047C:  MOVF   FEF,W
047E:  ANDLW  03
0480:  MOVWF  4F
0482:  CLRF   50
0484:  CLRF   51
0486:  CLRF   52
0488:  CLRF   00
048A:  CLRF   01
048C:  MOVF   00,W
048E:  IORWF  45,F
0490:  MOVF   01,W
0492:  IORWF  46,F
0494:  MOVF   4F,W
0496:  IORWF  47,F
0498:  MOVF   50,W
049A:  IORWF  48,F
....................       ret|=((int32)*ptr & 0xE0) << 13; 
049C:  MOVFF  49,FE9
04A0:  MOVFF  4A,FEA
04A4:  MOVF   FEF,W
04A6:  ANDLW  E0
04A8:  MOVWF  4F
04AA:  CLRF   50
04AC:  CLRF   51
04AE:  CLRF   52
04B0:  CLRF   00
04B2:  RLCF   4F,W
04B4:  MOVWF  01
04B6:  RLCF   50,W
04B8:  MOVWF  02
04BA:  RLCF   51,W
04BC:  MOVWF  03
04BE:  RLCF   01,F
04C0:  RLCF   02,F
04C2:  RLCF   03,F
04C4:  RLCF   01,F
04C6:  RLCF   02,F
04C8:  RLCF   03,F
04CA:  RLCF   01,F
04CC:  RLCF   02,F
04CE:  RLCF   03,F
04D0:  RLCF   01,F
04D2:  RLCF   02,F
04D4:  RLCF   03,F
04D6:  MOVLW  E0
04D8:  ANDWF  01,F
04DA:  MOVF   00,W
04DC:  IORWF  45,F
04DE:  MOVF   01,W
04E0:  IORWF  46,F
04E2:  MOVF   02,W
04E4:  IORWF  47,F
04E6:  MOVF   03,W
04E8:  IORWF  48,F
....................  
....................       ptr--;     //sidh 
04EA:  MOVF   49,W
04EC:  BTFSC  FD8.2
04EE:  DECF   4A,F
04F0:  DECF   49,F
....................       ret|=((int32)*ptr << 21); 
04F2:  MOVFF  49,FE9
04F6:  MOVFF  4A,FEA
04FA:  MOVF   FEF,W
04FC:  CLRF   4C
04FE:  MOVWF  4B
0500:  CLRF   00
0502:  CLRF   01
0504:  RLCF   4B,W
0506:  MOVWF  02
0508:  RLCF   4C,W
050A:  MOVWF  03
050C:  RLCF   02,F
050E:  RLCF   03,F
0510:  RLCF   02,F
0512:  RLCF   03,F
0514:  RLCF   02,F
0516:  RLCF   03,F
0518:  RLCF   02,F
051A:  RLCF   03,F
051C:  MOVLW  E0
051E:  ANDWF  02,F
0520:  MOVF   00,W
0522:  IORWF  45,F
0524:  MOVF   01,W
0526:  IORWF  46,F
0528:  MOVF   02,W
052A:  IORWF  47,F
052C:  MOVF   03,W
052E:  IORWF  48,F
....................  
....................    } 
....................    else { 
0530:  BRA    05D0
....................       ptr-=2;    //sidl 
0532:  MOVLW  02
0534:  SUBWF  49,F
0536:  MOVLW  00
0538:  SUBWFB 4A,F
....................       ret=((int32)*ptr & 0xE0) >> 5; 
053A:  MOVFF  49,FE9
053E:  MOVFF  4A,FEA
0542:  MOVF   FEF,W
0544:  ANDLW  E0
0546:  MOVWF  4F
0548:  CLRF   50
054A:  CLRF   51
054C:  CLRF   52
054E:  RRCF   52,W
0550:  MOVWF  48
0552:  RRCF   51,W
0554:  MOVWF  47
0556:  RRCF   50,W
0558:  MOVWF  46
055A:  RRCF   4F,W
055C:  MOVWF  45
055E:  RRCF   48,F
0560:  RRCF   47,F
0562:  RRCF   46,F
0564:  RRCF   45,F
0566:  RRCF   48,F
0568:  RRCF   47,F
056A:  RRCF   46,F
056C:  RRCF   45,F
056E:  RRCF   48,F
0570:  RRCF   47,F
0572:  RRCF   46,F
0574:  RRCF   45,F
0576:  RRCF   48,F
0578:  RRCF   47,F
057A:  RRCF   46,F
057C:  RRCF   45,F
057E:  MOVLW  07
0580:  ANDWF  48,F
....................  
....................       ptr--;     //sidh 
0582:  MOVF   49,W
0584:  BTFSC  FD8.2
0586:  DECF   4A,F
0588:  DECF   49,F
....................       ret|=((int32)*ptr << 3); 
058A:  MOVFF  49,FE9
058E:  MOVFF  4A,FEA
0592:  MOVF   FEF,W
0594:  CLRF   4E
0596:  CLRF   4D
0598:  CLRF   4C
059A:  MOVWF  4B
059C:  RLCF   4B,W
059E:  MOVWF  00
05A0:  RLCF   4C,W
05A2:  MOVWF  01
05A4:  RLCF   4D,W
05A6:  MOVWF  02
05A8:  RLCF   4E,W
05AA:  MOVWF  03
05AC:  RLCF   00,F
05AE:  RLCF   01,F
05B0:  RLCF   02,F
05B2:  RLCF   03,F
05B4:  RLCF   00,F
05B6:  RLCF   01,F
05B8:  RLCF   02,F
05BA:  RLCF   03,F
05BC:  MOVLW  F8
05BE:  ANDWF  00,F
05C0:  MOVF   00,W
05C2:  IORWF  45,F
05C4:  MOVF   01,W
05C6:  IORWF  46,F
05C8:  MOVF   02,W
05CA:  IORWF  47,F
05CC:  MOVF   03,W
05CE:  IORWF  48,F
....................    } 
....................  
....................    return(ret); 
05D0:  MOVFF  45,00
05D4:  MOVFF  46,01
05D8:  MOVFF  47,02
05DC:  MOVFF  48,03
.................... } 
05E0:  GOTO   09F4 (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_putd() 
.................... // 
.................... // Puts data on a transmit buffer, at which time the CAN peripheral will 
.................... // send when the CAN bus becomes available. 
.................... // 
.................... //    Paramaters: 
.................... //       id - ID to transmit data as 
.................... //       data - pointer to data to send 
.................... //       len - length of data to send 
.................... //       priority - priority of message.  The higher the number, the 
.................... //                  sooner the CAN peripheral will send the message. 
.................... //                  Numbers 0 through 3 are valid. 
.................... //       ext - TRUE to use an extended ID, FALSE if not 
.................... //       rtr - TRUE to set the RTR (request) bit in the ID, false if NOT 
.................... // 
.................... //    Returns: 
.................... //       If successful, it will return TRUE 
.................... //       If un-successful, will return FALSE 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_putd(int32 id, int * data, int len, int priority, int1 ext, int1 rtr) { 
....................    int i; 
....................    int * txd0; 
....................    int port; 
....................  
....................    txd0=&TXRXBaD0; 
05E4:  MOVLW  0F
05E6:  MOVWF  42
05E8:  MOVLW  66
05EA:  MOVWF  41
....................  
....................     // find emtpy transmitter 
....................     //map access bank addresses to empty transmitter 
....................    if (!TXB0CON.txreq) { 
05EC:  MOVLB  F
05EE:  BTFSC  x40.3
05F0:  BRA    05FE
....................       CANCON.win=CAN_WIN_TX0; 
05F2:  MOVLW  F1
05F4:  ANDWF  F6F,W
05F6:  IORLW  08
05F8:  MOVWF  F6F
....................       port=0; 
05FA:  CLRF   43
....................    } 
....................    else if (!TXB1CON.txreq) { 
05FC:  BRA    0628
05FE:  BTFSC  x30.3
0600:  BRA    0610
....................       CANCON.win=CAN_WIN_TX1; 
0602:  MOVLW  F1
0604:  ANDWF  F6F,W
0606:  IORLW  06
0608:  MOVWF  F6F
....................       port=1; 
060A:  MOVLW  01
060C:  MOVWF  43
....................    } 
....................    else if (!TXB2CON.txreq) { 
060E:  BRA    0628
0610:  BTFSC  x20.3
0612:  BRA    0622
....................       CANCON.win=CAN_WIN_TX2; 
0614:  MOVLW  F1
0616:  ANDWF  F6F,W
0618:  IORLW  04
061A:  MOVWF  F6F
....................       port=2; 
061C:  MOVLW  02
061E:  MOVWF  43
....................    } 
....................    else { 
0620:  BRA    0628
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nCAN_PUTD() FAIL: NO OPEN TX BUFFERS\r\n"); 
....................       #endif 
....................       return(0); 
0622:  MOVLW  00
0624:  MOVWF  01
0626:  BRA    069E
....................    } 
....................  
....................    //set priority. 
....................    TXBaCON.txpri=priority; 
0628:  MOVF   3D,W
062A:  ANDLW  03
062C:  MOVWF  00
062E:  MOVLW  FC
0630:  ANDWF  F60,W
0632:  IORWF  00,W
0634:  MOVWF  F60
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
0636:  MOVLW  0F
0638:  MOVWF  45
063A:  MOVLW  64
063C:  MOVWF  44
063E:  MOVFF  39,49
0642:  MOVFF  38,48
0646:  MOVFF  37,47
064A:  MOVFF  36,46
064E:  MOVFF  3E,4A
0652:  MOVLB  0
0654:  RCALL  0124
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
0656:  MOVFF  3C,F65
....................    TXBaDLC.rtr=rtr; 
065A:  BCF    F65.6
065C:  BTFSC  3F.0
065E:  BSF    F65.6
....................  
....................     for (i=0; i<len; i++) { 
0660:  CLRF   40
0662:  MOVF   3C,W
0664:  SUBWF  40,W
0666:  BC    0690
....................       *txd0=*data; 
0668:  MOVFF  3A,FE9
066C:  MOVFF  3B,FEA
0670:  MOVFF  FEF,46
0674:  MOVFF  42,FEA
0678:  MOVFF  41,FE9
067C:  MOVFF  46,FEF
....................       txd0++; 
0680:  INCF   41,F
0682:  BTFSC  FD8.2
0684:  INCF   42,F
....................       data++; 
0686:  INCF   3A,F
0688:  BTFSC  FD8.2
068A:  INCF   3B,F
....................     } 
068C:  INCF   40,F
068E:  BRA    0662
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
0690:  BSF    F60.3
....................  
....................    CANCON.win=CAN_WIN_RX0; 
0692:  MOVLW  F1
0694:  ANDWF  F6F,W
0696:  MOVWF  F6F
....................  
....................    #if CAN_DO_DEBUG 
....................             can_debug("\r\nCAN_PUTD(): BUFF=%U ID=%LX LEN=%U PRI=%U EXT=%U RTR=%U\r\n", port, id, len, priority, ext, rtr); 
....................             if ((len)&&(!rtr)) { 
....................                data-=len; 
....................                can_debug("  DATA = "); 
....................                for (i=0;i<len;i++) { 
....................                   can_debug("%X ",*data); 
....................                   data++; 
....................                } 
....................                can_debug("\r\n"); 
....................             } 
....................    #endif 
....................  
....................    return(1); 
0698:  MOVLW  01
069A:  MOVWF  01
069C:  MOVLB  F
.................... } 
069E:  MOVLB  0
06A0:  GOTO   0ABC (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_getd() 
.................... // 
.................... // Gets data from a receive buffer, if the data exists 
.................... // 
.................... //    Returns: 
.................... //      id - ID who sent message 
.................... //      data - pointer to array of data 
.................... //      len - length of received data 
.................... //      stat - structure holding some information (such as which buffer 
.................... //             recieved it, ext or standard, etc) 
.................... // 
.................... //    Returns: 
.................... //      Function call returns a TRUE if there was data in a RX buffer, FALSE 
.................... //      if there was none. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_getd(int32 & id, int * data, int & len, struct rx_stat & stat) 
.................... { 
....................     int i; 
....................     int * ptr; 
....................  
....................     if (RXB0CON.rxful) { 
*
0962:  BTFSS  F60.7
0964:  BRA    0994
....................         CANCON.win=CAN_WIN_RX0; 
0966:  MOVLW  F1
0968:  ANDWF  F6F,W
096A:  MOVWF  F6F
....................         stat.buffer=0; 
096C:  BCF    28.4
....................  
....................         CAN_INT_RXB0IF=0; 
096E:  BCF    FA4.0
....................  
....................         stat.err_ovfl=COMSTAT.rx0ovfl; 
0970:  BCF    28.0
0972:  BTFSC  F74.7
0974:  BSF    28.0
....................         COMSTAT.rx0ovfl=0; 
0976:  BCF    F74.7
....................  
....................         if (RXB0CON.rxb0dben) { 
0978:  BTFSS  F60.2
097A:  BRA    0992
....................          stat.filthit=RXB0CON.filthit0; 
097C:  MOVLW  00
097E:  BTFSC  F60.0
0980:  MOVLW  01
0982:  ANDLW  07
0984:  MOVWF  00
0986:  BCF    FD8.0
0988:  RLCF   00,F
098A:  MOVLW  F1
098C:  ANDWF  28,W
098E:  IORWF  00,W
0990:  MOVWF  28
....................         } 
....................     } 
....................     else if ( RXB1CON.rxful ) 
0992:  BRA    09CC
0994:  MOVLB  F
0996:  BTFSS  x50.7
0998:  BRA    09C4
....................     { 
....................         CANCON.win=CAN_WIN_RX1; 
099A:  MOVLW  F1
099C:  ANDWF  F6F,W
099E:  IORLW  0A
09A0:  MOVWF  F6F
....................         stat.buffer=1; 
09A2:  BSF    28.4
....................  
....................         CAN_INT_RXB1IF=0; 
09A4:  BCF    FA4.1
....................  
....................         stat.err_ovfl=COMSTAT.rx1ovfl; 
09A6:  BCF    28.0
09A8:  BTFSC  F74.6
09AA:  BSF    28.0
....................         COMSTAT.rx1ovfl=0; 
09AC:  BCF    F74.6
....................  
....................         stat.filthit=RXB1CON.filthit; 
09AE:  MOVF   x50,W
09B0:  ANDLW  07
09B2:  ANDLW  07
09B4:  MOVWF  00
09B6:  BCF    FD8.0
09B8:  RLCF   00,F
09BA:  MOVLW  F1
09BC:  ANDWF  28,W
09BE:  IORWF  00,W
09C0:  MOVWF  28
....................     } 
....................     else { 
09C2:  BRA    09CA
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nFAIL ON CAN_GETD(): NO MESSAGE IN BUFFER\r\n"); 
....................       #endif 
....................       return (0); 
09C4:  MOVLW  00
09C6:  MOVWF  01
09C8:  BRA    0A5E
09CA:  MOVLB  0
....................     } 
....................  
....................     len = RXBaDLC.dlc; 
09CC:  MOVF   F65,W
09CE:  ANDLW  0F
09D0:  MOVWF  35
....................     stat.rtr=RXBaDLC.rtr; 
09D2:  BCF    28.5
09D4:  BTFSC  F65.6
09D6:  BSF    28.5
....................  
....................     stat.ext=TXRXBaSIDL.ext; 
09D8:  BCF    28.6
09DA:  BTFSC  F62.3
09DC:  BSF    28.6
....................     id=can_get_id(TXRXBaID,stat.ext); 
09DE:  MOVLW  00
09E0:  BTFSC  28.6
09E2:  MOVLW  01
09E4:  MOVWF  3B
09E6:  MOVLW  0F
09E8:  MOVWF  43
09EA:  MOVLW  64
09EC:  MOVWF  42
09EE:  MOVFF  3B,44
09F2:  BRA    0406
09F4:  MOVFF  03,2C
09F8:  MOVFF  02,2B
09FC:  MOVFF  01,2A
0A00:  MOVFF  00,29
....................  
....................     ptr = &TXRXBaD0; 
0A04:  MOVLW  0F
0A06:  MOVWF  3A
0A08:  MOVLW  66
0A0A:  MOVWF  39
....................     for ( i = 0; i < len; i++ ) { 
0A0C:  CLRF   38
0A0E:  MOVF   35,W
0A10:  SUBWF  38,W
0A12:  BC    0A3C
....................         *data = *ptr; 
0A14:  MOVFF  39,FE9
0A18:  MOVFF  3A,FEA
0A1C:  MOVFF  FEF,3D
0A20:  MOVFF  37,FEA
0A24:  MOVFF  36,FE9
0A28:  MOVFF  3D,FEF
....................         data++; 
0A2C:  INCF   36,F
0A2E:  BTFSC  FD8.2
0A30:  INCF   37,F
....................         ptr++; 
0A32:  INCF   39,F
0A34:  BTFSC  FD8.2
0A36:  INCF   3A,F
....................     } 
0A38:  INCF   38,F
0A3A:  BRA    0A0E
....................  
....................     // return to default addressing 
....................     CANCON.win=CAN_WIN_RX0; 
0A3C:  MOVLW  F1
0A3E:  ANDWF  F6F,W
0A40:  MOVWF  F6F
....................  
....................     stat.inv=CAN_INT_IRXIF; 
0A42:  BCF    28.7
0A44:  BTFSC  FA4.7
0A46:  BSF    28.7
....................     CAN_INT_IRXIF = 0; 
0A48:  BCF    FA4.7
....................  
....................     if (stat.buffer) { 
0A4A:  BTFSS  28.4
0A4C:  BRA    0A56
....................       RXB1CON.rxful=0; 
0A4E:  MOVLB  F
0A50:  BCF    x50.7
....................     } 
....................     else { 
0A52:  BRA    0A5A
0A54:  MOVLB  0
....................       RXB0CON.rxful=0; 
0A56:  BCF    F60.7
0A58:  MOVLB  F
....................     } 
....................  
....................     #if CAN_DO_DEBUG 
....................        can_debug("\r\nCAN_GETD(): BUFF=%U ID=%LX LEN=%U OVF=%U ", stat.buffer, id, len, stat.err_ovfl); 
....................        can_debug("FILT=%U RTR=%U EXT=%U INV=%U", stat.filthit, stat.rtr, stat.ext, stat.inv); 
....................        if ((len)&&(!stat.rtr)) { 
....................           data-=len; 
....................           can_debug("\r\n    DATA = "); 
....................           for (i=0;i<len;i++) { 
....................             can_debug("%X ",*data); 
....................             data++; 
....................           } 
....................        } 
....................        can_debug("\r\n"); 
....................     #endif 
....................  
....................     return(1); 
0A5A:  MOVLW  01
0A5C:  MOVWF  01
.................... } 
....................  
....................  
....................  
....................  
.................... #include <CAN_id_v2.h> 
.................... //  CAN_id_v2 
.................... //  Version 2.0 - HDT - 20/04/2011 
.................... //  Version 2.1 - HDT - 22/04/2011 
....................  
.................... // Acknowledge IDs (0~99) 
....................  
.................... #define MAB_BRAKE_ACK_ID    0// acknowledge de frein (provient de la MicroAutoBox) 
.................... #define MAB_BOOST_ACK_ID    1// acknowledge de boost (provient de la MicroAutoBox) 
.................... #define MAB_ERRSC_ACK_ID    2// acknowledge d'erreurs supercapas (provient de la MicroAutoBox) 
.................... #define ARR_STOP_ACK_ID     3// acknowledge des feux stop (provient de la carte phares arrière) 
....................  
.................... // High Priority IDs (100~199) 
....................  
.................... #define TDB_BRAKE_ID        100// frein (provient du tableau de bord) 
.................... #define TDB_BOOST_ID        110// boost (provient du tableau de bord) 
.................... #define SCP_ERR_ID          120// erreurs de supercapas 
.................... #define MAB_STOP_ID         130// feux stop (provient de la MicroAutoBox) 
....................  
.................... // Medium/low Priority IDs (200~infinity) 
....................  
.................... #define SCP_TEMP_ID         200// température supercapas 
.................... #define ALM_CHARGE_ID       210// charge de la batterie (provient de la carte alim) 
.................... #define AVT_VITESSE_ID      215// vitesse du véhicule (provient de la carte vitesse phares avant) 
.................... #define TDB_PHARES_ID       220// phares (provient du tableau de bord) 
....................  
....................  
.................... #define PHARES_G        PIN_A1  //réceptionné par CAN 
.................... #define PHARES_D        PIN_A3  //réceptionné par CAN 
.................... #define CODES_G         PIN_B1  //réceptionné par CAN 
.................... #define CODES_D         PIN_C4  //réceptionné par CAN 
.................... #define CLIGNO_G        PIN_A5  //réceptionné par CAN 
.................... #define CLIGNO_D        PIN_C1  //réceptionné par CAN 
.................... #define VITESSE_A       PIN_A4  //destiné à être envoyé par CAN 
.................... #define VITESSE_B       PIN_C0  //destiné à être envoyé par CAN 
....................  
.................... #define VITESSE_SEUIL   10 
.................... #define CSTE_CAPT_A      322 
.................... #define CSTE_CAPT_B      322 
....................  
.................... #fuses HS,NOPROTECT,NOLVP,NOWDT 
.................... #use delay(clock=20000000) 
....................  
.................... // Variables utilisées 
.................... int8 vitesseA = 0; //donnée après calcul 
.................... int8 vitesseB = 0; //donnée après calcul 
....................  
.................... int32 msA = 0;          //pour les mesures de vitesse 
.................... int32 msB = 0; 
.................... int16 ms_clign = 0;     //pour la période des clignotants 
.................... int16 ms = 0;           //pour l'envoi régulier du signal de vitesse 
....................  
.................... int1 phares = false; 
.................... int1 codes = false; 
.................... int1 clignd = false; 
.................... int1 cligng = false; 
....................  
.................... int1 clign_on = false; 
.................... int1 timer_active = false; 
.................... int1 mode_mesureA = true;        //true -> mode "rapide" (vitesseA > VITESSE_SEUIL), false -> mode "lent" 
.................... int1 mode_mesureB = true;        //true -> mode "rapide" (vitesseB > VITESSE_SEUIL), false -> mode "lent" 
....................  
.................... int1 send_vitesse = false; 
....................  
.................... // Fonctions 
....................  
.................... #inline 
.................... void manageCAN(); 
....................  
.................... #inline 
.................... void internalLogic(); 
....................  
.................... #int_timer2 
.................... void isr_timer2()       // lors de l'interruption du timer 2 (timer global) au bout d'une milliseconde 
.................... { 
....................     msA++;             // ajouter 1 ms. 
*
009E:  MOVLW  01
00A0:  ADDWF  1A,F
00A2:  BTFSC  FD8.0
00A4:  INCF   1B,F
00A6:  BTFSC  FD8.2
00A8:  INCF   1C,F
00AA:  BTFSC  FD8.2
00AC:  INCF   1D,F
....................     msB++; 
00AE:  MOVLW  01
00B0:  ADDWF  1E,F
00B2:  BTFSC  FD8.0
00B4:  INCF   1F,F
00B6:  BTFSC  FD8.2
00B8:  INCF   20,F
00BA:  BTFSC  FD8.2
00BC:  INCF   21,F
....................     if(timer_active)   ms_clign++; 
00BE:  BTFSS  26.5
00C0:  BRA    00C8
00C2:  INCF   22,F
00C4:  BTFSC  FD8.2
00C6:  INCF   23,F
....................     ms++; 
00C8:  INCF   24,F
00CA:  BTFSC  FD8.2
00CC:  INCF   25,F
.................... } 
....................  
00CE:  BCF    F9E.1
00D0:  GOTO   0058
.................... #org DEFAULT 
.................... void main() 
.................... { 
*
06A4:  CLRF   FF8
06A6:  BCF    FD0.7
06A8:  BSF    0D.7
06AA:  CLRF   FEA
06AC:  CLRF   FE9
06AE:  MOVF   FC1,W
06B0:  ANDLW  C0
06B2:  IORLW  0F
06B4:  MOVWF  FC1
06B6:  CLRF   18
06B8:  CLRF   19
06BA:  CLRF   1A
06BC:  CLRF   1B
06BE:  CLRF   1C
06C0:  CLRF   1D
06C2:  CLRF   1E
06C4:  CLRF   1F
06C6:  CLRF   20
06C8:  CLRF   21
06CA:  CLRF   22
06CC:  CLRF   23
06CE:  CLRF   24
06D0:  CLRF   25
06D2:  BCF    26.0
06D4:  BCF    26.1
06D6:  BCF    26.2
06D8:  BCF    26.3
06DA:  BCF    26.4
06DC:  BCF    26.5
06DE:  BSF    26.6
06E0:  BSF    26.7
06E2:  BCF    27.0
....................    setup_adc_ports(NO_ANALOGS); 
06E4:  MOVF   FC1,W
06E6:  ANDLW  C0
06E8:  IORLW  0F
06EA:  MOVWF  FC1
....................  
....................    set_tris_a(0b00010000); 
06EC:  MOVLW  10
06EE:  MOVWF  F92
....................    set_tris_c(0b00000001); 
06F0:  MOVLW  01
06F2:  MOVWF  F94
....................  
....................    enable_interrupts(INT_TIMER2); 
06F4:  BSF    F9D.1
....................    enable_interrupts(GLOBAL); 
06F6:  MOVLW  C0
06F8:  IORWF  FF2,F
....................  
....................    setup_timer_0(RTCC_EXT_L_TO_H);     //incrémente à chaque front montant (1 tour de roue) 
06FA:  MOVLW  A0
06FC:  MOVWF  FD5
....................    setup_timer_1(T1_EXTERNAL);         //incrémente à chaque front montant (1 tour de roue) 
06FE:  MOVLW  87
0700:  MOVWF  FCD
....................    setup_timer_2(T2_DIV_BY_4,79,16);   //setup up timer2 to interrupt every 1ms 
0702:  MOVLW  78
0704:  IORLW  05
0706:  MOVWF  FCA
0708:  MOVLW  4F
070A:  MOVWF  FCB
....................  
....................    can_init(); 
070C:  BRA    0254
....................    can_set_baud(); 
070E:  RCALL  00F6
....................  
....................    //  BOUCLE DE TRAVAIL 
....................    while(true) 
....................    { 
....................       internalLogic(); 
....................       manageCAN(); 
....................    } 
*
0ABE:  MOVLB  0
0AC0:  BRA    0710
.................... } 
....................  
.................... #inline 
.................... void manageCAN() 
0AC2:  SLEEP 
.................... { 
....................    struct rx_stat rxStat; 
....................    int32 rxId; 
....................    int8 rxData[8]; 
....................    int8 rxLen; 
....................  
....................    if(can_kbhit()) 
*
0950:  BTFSC  F60.7
0952:  BRA    095C
0954:  MOVLB  F
0956:  BTFSS  x50.7
0958:  BRA    0A8C
095A:  MOVLB  0
....................    { 
....................       if(can_getd(rxId,rxData,rxLen,rxStat)) 
095C:  CLRF   37
095E:  MOVLW  2D
0960:  MOVWF  36
*
0A5E:  MOVF   01,F
0A60:  BZ    0A8C
....................       { 
....................             if(rxId == TDB_PHARES_ID)        // on veut modifier les feux avant ? Utiliser rxData pour activer ou désactiver les feux. 
0A62:  MOVF   29,W
0A64:  SUBLW  DC
0A66:  BNZ   0A8C
0A68:  MOVF   2A,F
0A6A:  BNZ   0A8C
0A6C:  MOVF   2B,F
0A6E:  BNZ   0A8C
0A70:  MOVF   2C,F
0A72:  BNZ   0A8C
....................             { 
....................                 phares = rxData[0]; 
0A74:  BCF    26.0
0A76:  BTFSC  2D.0
0A78:  BSF    26.0
....................                 codes = rxData[1]; 
0A7A:  BCF    26.1
0A7C:  BTFSC  2E.0
0A7E:  BSF    26.1
....................                 cligng = rxData[2]; 
0A80:  BCF    26.3
0A82:  BTFSC  2F.0
0A84:  BSF    26.3
....................                 clignd = rxData[3]; 
0A86:  BCF    26.2
0A88:  BTFSC  30.0
0A8A:  BSF    26.2
....................             } 
....................       } 
....................    } 
....................  
....................    if (can_tbe()) 
0A8C:  BTFSS  x40.3
0A8E:  BRA    0A98
0A90:  BTFSS  x30.3
0A92:  BRA    0A98
0A94:  BTFSC  x20.3
0A96:  BRA    0ABE
....................     { 
....................         if(send_vitesse) 
0A98:  BTFSS  27.0
0A9A:  BRA    0ABE
....................             can_putd(AVT_VITESSE_ID,&vitesseA,8,1,1,0); //envoi de "vitesse" : moyenne des deux ? 
0A9C:  CLRF   39
0A9E:  CLRF   38
0AA0:  CLRF   37
0AA2:  MOVLW  D7
0AA4:  MOVWF  36
0AA6:  CLRF   3B
0AA8:  MOVLW  18
0AAA:  MOVWF  3A
0AAC:  MOVLW  08
0AAE:  MOVWF  3C
0AB0:  MOVLW  01
0AB2:  MOVWF  3D
0AB4:  MOVWF  3E
0AB6:  CLRF   3F
0AB8:  MOVLB  0
0ABA:  BRA    05E4
0ABC:  MOVLB  F
....................     } 
.................... } 
....................  
.................... #inline 
.................... void internalLogic() 
.................... { 
....................    output_bit(PHARES_D, phares); 
*
0710:  BTFSC  26.0
0712:  BRA    0718
0714:  BCF    F89.3
0716:  BRA    071A
0718:  BSF    F89.3
071A:  BCF    F92.3
....................    output_bit(PHARES_G, phares);          // si phares est à true, allumer le phare avant gauche (resp. droit), et inversement 
071C:  BTFSC  26.0
071E:  BRA    0724
0720:  BCF    F89.1
0722:  BRA    0726
0724:  BSF    F89.1
0726:  BCF    F92.1
....................     output_bit(CODES_D, codes); 
0728:  BTFSC  26.1
072A:  BRA    0730
072C:  BCF    F8B.4
072E:  BRA    0732
0730:  BSF    F8B.4
0732:  BCF    F94.4
....................    output_bit(CODES_G, codes);            // si codes est à true, allumer le feu de codes gauche (resp. droit), et inversement 
0734:  BTFSC  26.1
0736:  BRA    073C
0738:  BCF    F8A.1
073A:  BRA    073E
073C:  BSF    F8A.1
073E:  BCF    F93.1
....................  
....................    timer_active = cligng|clignd;          // si des clignos doivent être allumés, on active le timer de clignotants (latence max. 1ms) 
0740:  MOVLW  00
0742:  BTFSC  26.3
0744:  MOVLW  01
0746:  MOVWF  28
0748:  MOVLW  00
074A:  BTFSC  26.2
074C:  MOVLW  01
074E:  IORWF  28,W
0750:  BCF    26.5
0752:  BTFSC  FE8.0
0754:  BSF    26.5
....................    if(!timer_active)   ms_clign = 0; 
0756:  BTFSC  26.5
0758:  BRA    075E
075A:  CLRF   23
075C:  CLRF   22
....................  
....................    if(ms_clign == 500)                          // environ 500 ms après l'activation du timer 1 
075E:  MOVF   22,W
0760:  SUBLW  F4
0762:  BNZ   0796
0764:  DECFSZ 23,W
0766:  BRA    0796
....................    { 
....................       ms_clign = 0;                           // repartir pour 500 ms 
0768:  CLRF   23
076A:  CLRF   22
....................       clign_on = !clign_on;                   // changer l'état d'allumage des clignotants 
076C:  BTFSS  26.4
076E:  BRA    0774
0770:  BCF    26.4
0772:  BRA    0776
0774:  BSF    26.4
....................  
....................       output_bit(CLIGNO_D, clign_on && clignd); 
0776:  BTFSS  26.4
0778:  BRA    077E
077A:  BTFSC  26.2
077C:  BRA    0782
077E:  BCF    F8B.1
0780:  BRA    0784
0782:  BSF    F8B.1
0784:  BCF    F94.1
....................                                                 // allumer ou éteindre le cligno droit s'il est activé 
....................       output_bit(CLIGNO_G, clign_on && cligng); 
0786:  BTFSS  26.4
0788:  BRA    078E
078A:  BTFSC  26.3
078C:  BRA    0792
078E:  BCF    F89.5
0790:  BRA    0794
0792:  BSF    F89.5
0794:  BCF    F92.5
....................                                                 // allumer ou éteindre le cligno gauche s'il est activé 
....................    } 
....................  
....................     //mode rapide 
....................     if(mode_mesureA) 
0796:  BTFSS  26.6
0798:  BRA    07F4
....................     { 
....................         if(msA == 1000) 
079A:  MOVF   1A,W
079C:  SUBLW  E8
079E:  BNZ   07F2
07A0:  MOVF   1B,W
07A2:  SUBLW  03
07A4:  BNZ   07F2
07A6:  MOVF   1C,F
07A8:  BNZ   07F2
07AA:  MOVF   1D,F
07AC:  BNZ   07F2
....................         { 
....................             msA = 0; 
07AE:  CLRF   1D
07B0:  CLRF   1C
07B2:  CLRF   1B
07B4:  CLRF   1A
....................             vitesseA = (get_timer0() * CSTE_CAPT_A) / 100; 
07B6:  MOVF   FD6,W
07B8:  MOVFF  FD7,03
07BC:  MOVWF  28
07BE:  MOVFF  FD7,29
07C2:  MOVFF  FD7,2B
07C6:  MOVWF  2A
07C8:  MOVLW  01
07CA:  MOVWF  2D
07CC:  MOVLW  42
07CE:  MOVWF  2C
07D0:  RCALL  032C
07D2:  MOVFF  02,2A
07D6:  MOVFF  01,29
07DA:  MOVFF  02,2C
07DE:  MOVFF  01,2B
07E2:  CLRF   2E
07E4:  MOVLW  64
07E6:  MOVWF  2D
07E8:  RCALL  034A
07EA:  MOVFF  01,18
....................             set_timer0(0); 
07EE:  CLRF   FD7
07F0:  CLRF   FD6
....................         } 
....................     } 
....................     else 
07F2:  BRA    085E
....................     { 
....................         if(get_timer0() >= 1) 
07F4:  MOVF   FD6,W
07F6:  MOVFF  FD7,03
07FA:  MOVWF  28
07FC:  MOVFF  FD7,29
0800:  MOVF   29,F
0802:  BNZ   080A
0804:  MOVF   28,W
0806:  SUBLW  00
0808:  BC    085E
....................         { 
....................             vitesseA = (CSTE_CAPT_A * 10 * get_timer0()) / msA; 
080A:  MOVF   FD6,W
080C:  MOVFF  FD7,03
0810:  MOVWF  28
0812:  MOVFF  FD7,29
0816:  MOVLW  0C
0818:  MOVWF  2B
081A:  MOVLW  94
081C:  MOVWF  2A
081E:  MOVFF  FD7,2D
0822:  MOVFF  28,2C
0826:  RCALL  032C
0828:  MOVFF  02,2A
082C:  MOVFF  01,29
0830:  CLRF   2E
0832:  CLRF   2D
0834:  MOVFF  02,2C
0838:  MOVFF  01,2B
083C:  MOVFF  1D,32
0840:  MOVFF  1C,31
0844:  MOVFF  1B,30
0848:  MOVFF  1A,2F
084C:  RCALL  038C
084E:  MOVFF  00,18
....................             msA = 0; 
0852:  CLRF   1D
0854:  CLRF   1C
0856:  CLRF   1B
0858:  CLRF   1A
....................             set_timer0(0); 
085A:  CLRF   FD7
085C:  CLRF   FD6
....................         } 
....................     } 
....................  
....................     if(mode_mesureB) 
085E:  BTFSS  26.7
0860:  BRA    08BC
....................     { 
....................         if(msB == 1000) 
0862:  MOVF   1E,W
0864:  SUBLW  E8
0866:  BNZ   08BA
0868:  MOVF   1F,W
086A:  SUBLW  03
086C:  BNZ   08BA
086E:  MOVF   20,F
0870:  BNZ   08BA
0872:  MOVF   21,F
0874:  BNZ   08BA
....................         { 
....................             msB = 0; 
0876:  CLRF   21
0878:  CLRF   20
087A:  CLRF   1F
087C:  CLRF   1E
....................             vitesseB = (get_timer1() * CSTE_CAPT_B) / 100; 
087E:  MOVF   FCE,W
0880:  MOVFF  FCF,03
0884:  MOVWF  28
0886:  MOVFF  FCF,29
088A:  MOVFF  FCF,2B
088E:  MOVWF  2A
0890:  MOVLW  01
0892:  MOVWF  2D
0894:  MOVLW  42
0896:  MOVWF  2C
0898:  RCALL  032C
089A:  MOVFF  02,2A
089E:  MOVFF  01,29
08A2:  MOVFF  02,2C
08A6:  MOVFF  01,2B
08AA:  CLRF   2E
08AC:  MOVLW  64
08AE:  MOVWF  2D
08B0:  RCALL  034A
08B2:  MOVFF  01,19
....................             set_timer1(0); 
08B6:  CLRF   FCF
08B8:  CLRF   FCE
....................         } 
....................     } 
....................     else 
08BA:  BRA    0926
....................     { 
....................         if(get_timer1() >= 1) 
08BC:  MOVF   FCE,W
08BE:  MOVFF  FCF,03
08C2:  MOVWF  28
08C4:  MOVFF  FCF,29
08C8:  MOVF   29,F
08CA:  BNZ   08D2
08CC:  MOVF   28,W
08CE:  SUBLW  00
08D0:  BC    0926
....................         { 
....................             vitesseB = (CSTE_CAPT_B * 10 * get_timer1()) / msB; 
08D2:  MOVF   FCE,W
08D4:  MOVFF  FCF,03
08D8:  MOVWF  28
08DA:  MOVFF  FCF,29
08DE:  MOVLW  0C
08E0:  MOVWF  2B
08E2:  MOVLW  94
08E4:  MOVWF  2A
08E6:  MOVFF  FCF,2D
08EA:  MOVFF  28,2C
08EE:  RCALL  032C
08F0:  MOVFF  02,2A
08F4:  MOVFF  01,29
08F8:  CLRF   2E
08FA:  CLRF   2D
08FC:  MOVFF  02,2C
0900:  MOVFF  01,2B
0904:  MOVFF  21,32
0908:  MOVFF  20,31
090C:  MOVFF  1F,30
0910:  MOVFF  1E,2F
0914:  RCALL  038C
0916:  MOVFF  00,19
....................             msB = 0; 
091A:  CLRF   21
091C:  CLRF   20
091E:  CLRF   1F
0920:  CLRF   1E
....................             set_timer1(0); 
0922:  CLRF   FCF
0924:  CLRF   FCE
....................         } 
....................     } 
....................  
....................     if(ms >= 500) 
0926:  MOVF   25,W
0928:  SUBLW  00
092A:  BC    093C
092C:  XORLW  FF
092E:  BNZ   0936
0930:  MOVF   24,W
0932:  SUBLW  F3
0934:  BC    093C
....................     { 
....................         send_vitesse = true; 
0936:  BSF    27.0
....................         ms = 0; 
0938:  CLRF   25
093A:  CLRF   24
....................     } 
....................  
....................     mode_mesureA = (vitesseA > VITESSE_SEUIL); 
093C:  BCF    26.6
093E:  MOVF   18,W
0940:  SUBLW  0A
0942:  BC    0946
0944:  BSF    26.6
....................     mode_mesureB = (vitesseB > VITESSE_SEUIL); 
0946:  BCF    26.7
0948:  MOVF   19,W
094A:  SUBLW  0A
094C:  BC    0950
094E:  BSF    26.7
.................... } 

Configuration Fuses:
   Word  1: 0200   HS NOIESO NOFCMEN RESERVED
   Word  2: 1E1E   BROWNOUT NOWDT BORV21 PUT WDT32768
   Word  3: 8200   PBADEN NOLPT1OSC MCLR RESERVED
   Word  4: 0081   STVREN NODEBUG NOLVP BBSIZ1K NOXINST RESERVED
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
